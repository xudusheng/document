> &emsp;&emsp;在互联网中的每一刻，你可能都在享受着Base64带来的便捷，但对于Base64的基础原理又了解多少？今天这篇博文带领大家了解一下Base64的底层实现。

### Base64编码的由来
&emsp;&emsp;目前Base64已经成为网络上常见的传输8Bit字节代码的编码方式之一。在做支付系统时，系统之间的报文交互都需要使用Base64对明文进行转码，然后再进行签名或加密，之后再进行（或再次Base64）传输。那么，Base64到底起到什么作用呢？

&emsp;&emsp;在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。

&emsp;&emsp;电子邮件刚问世的时候，只能传输英文，但后来随着用户的增加，中文、日文等文字的用户也有需求，但这些字符并不能被服务器或网关有效处理，因此Base64就登场了。随之，Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。

### Base64的编码原理
&emsp;&emsp;Base64的原理比较简单，每当我们使用Base64时都会先定义一个类似这样的数组：
> ['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']

&emsp;&emsp;上面就是Base64的索引表，字符选用了"A-Z、a-z、0-9、+、/" 64个可打印字符，这是标准的Base64协议规定。在日常使用中我们还会看到“=”或“==”号出现在Base64的编码结果中，“=”在此是作为填充字符出现，后面会讲到。

### 具体转换步骤
*   第一步，将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。
*   第二步，将上面的24个二进制位每6个一组，共分为4组。
*   第三步，在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。
*   第四步，根据Base64编码对照表（见下表）获得对应的值。
Base64编码表

| 码值 | 字符|码值 | 字符 |  | 码值 | 字符 | 码值 | 字符 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0 |	A | 16 | Q || 32 | g | 48 | w |
| 1 | B | 17 | R || 33 | h | 49 | x |
| 2 | C | 18 | S || 34 | i | 50 | y |
| 3 | D | 19 | T || 35 | j | 51 | z |
| 4 | E | 20 | U || 36 | k | 52 | 0 |
| 5 | F | 21 | V || 37 | l | 53 | 1 |
| 6 | G | 22 | W || 38 | m | 54 | 2 |
| 7 | H | 23 | X || 39 | n | 55 | 3 |
| 8 | I | 24 | Y || 40 | o | 56 | 4 |
| 9 | J | 25 | Z || 41 | p | 57 | 5 |
| 10 | K | 26 | a || 42 | q | 58 | 6 |
| 11 | L | 27 | b || 43 | r | 59 | 7 |
| 12 | M | 28 | c || 44 | s | 60 | 8 |
| 13 | N | 29 | d || 45 | t | 61 | 9 |
| 14 | O | 30 | e || 46 | u | 62 | + |
| 15 | P | 31 | f || 47 | v | 63 | / |

从上面的步骤我们发现：
* Base64字符表中的字符原本用6个bit就可以表示，现在前面添加2个0，变为8个bit，会造成一定的浪费。因此，Base64编码之后的文本，要比原文大约三分之一。
* 为什么使用3个字节一组呢？因为6和8的最小公倍数为24，三个字节正好24个二进制位，每6个bit位一组，恰好能够分为4组。

### 示例说明
以下图的表格为示例，我们具体分析一下整个过程。![image](https://xudusheng.github.io/document/zh-cn/iOS笔记/密码学/images/base64_1.png) 
* 第一步：“d”、“o”、"g"对应的ASCII码值分别为100，111，103，对应的二进制值是01100100、01101111、01100111。如图第3、4行所示，由此组成一个24位的二进制字符串。
* 第二步：如图第4行，将24位每6位二进制位一组分成四组。
* 第三步：在上面每一组前面补两个0，扩展成32个二进制位，此时变为四个字节：00010011、00010110、00000101、00101110。分别对应的值（Base64编码索引）为：25、6、61、39。
* 第四步：用上面的值在Base64编码表中进行查找，分别对应：Z、G、9、n。因此“dog”Base64编码之后就变为：ZG9n。

#### 终端命令行验证
```Shell
# 把桌面的demo.json文件base64加密
cd Desktop/
base64 demo.json -o demo.txt # 加密, -o 后面跟着是输出目录
base64 -D demo.txt -o 123.json # 解密, -o 后面跟着是输出目录
# 把"Mac"字符串进行base64加密,并回显输出
echo -n "dog" | base64
# 把"ZG9n"字符串通过base64解密,并回显输出
echo -n "ZG9n" | base64 -D
```
### 位数不足情况
&emsp;&emsp;上面是按照三个字节来举例说明的，如果字节数不足三个，那么该如何处理？![image](https://xudusheng.github.io/document/zh-cn/iOS笔记/密码学/images/base64_2.png) 
* 一个字节：一个字节共8个二进制位，依旧按照规则进行分组。此时共8个二进制位，每6个一组，则第二组缺少4位，用0补齐，得到两个Base64编码，而后面两组没有对应数据，都用“=”补上。因此，上图中“d”转换之后为“ZA==”；
* 两个字节：两个字节共16个二进制位，依旧按照规则进行分组。此时总共16个二进制位，每6个一组，则第三组缺少2位，用0补齐，得到三个Base64编码，第四组完全没有数据则用“=”补上。因此，上图中“do”转换之后为“ZG8=”；
* 三个字节：三个字节共24个二进制位，依旧按照规则进行分组。此时总共24个二进制位，每6个一组，刚好分为4组，无需补齐。因此，上图中“dog”转换之后为“ZG9n”；

### 注意事项
*   大多数编码都是由字符串转化成二进制的过程，而Base64的编码则是从二进制转换为字符串。与常规恰恰相反。
*   Base64编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱Base64编码来进行加密。
*   中文有多种编码（比如：utf-8、gb2312、gbk等），不同编码对应Base64编码结果都不一样。

## 延伸
&emsp;&emsp;上面我们已经看到了Base64就是用6位（2的6次幂就是64）表示字符，因此成为Base64。同理，Base32就是用5位，Base16就是用4位。大家可以按照上面的步骤进行演化一下。
### Objective-C代码验证
&emsp;&emsp;最后，我们用一段Objective-C代码来验证一下上面的转换结果。
```ObjC
- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"编码：%@",[self base64Encode:@"dog"]);
    NSLog(@"解码：%@",[self base64Decode:@"ZG9n"]);
}

//字符串转base64编码
-(NSString *)base64Encode:(NSString *)string{
    NSData * data = [string dataUsingEncoding:NSUTF8StringEncoding];
    return [data base64EncodedStringWithOptions:0];
}

//base64转字符串
-(NSString *)base64Decode:(NSString *)str{
    NSData * data = [[NSData alloc] initWithBase64EncodedString:str options:0];
    return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
}
````

打印结果为：
```
base64Demo[4947:200140] 编码：ZG9n
base64Demo[4947:200140] 解码：dog
```
以上结果与我们分析所得完全一致。